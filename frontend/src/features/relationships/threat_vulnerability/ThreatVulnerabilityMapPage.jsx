// src/features/relationships/threat_vulnerability/ThreatVulnerabilityMapPage.jsx

import React, { useEffect, useState } from 'react';
import { Box, Grid, Typography, Snackbar, Alert } from '@mui/material';
import { getThreats } from './api';
import { getVulnerabilities } from './api';
import {
  getLinksByThreat,
  createLink,
  deleteLink
} from './api';

import ThreatList from './ThreatList';
import VulnerabilityList from './VulnerabilityList';

const ThreatVulnerabilityMapPage = () => {
  const [threats, setThreats] = useState([]);
  const [vulnerabilities, setVulnerabilities] = useState([]);
  const [selectedThreat, setSelectedThreat] = useState(null);
  const [linkedVulnIds, setLinkedVulnIds] = useState([]);
  const [selectedVulnIds, setSelectedVulnIds] = useState([]);
  const [loading, setLoading] = useState(false);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });

  useEffect(() => {
    getThreats().then(res => setThreats(res.data));
    getVulnerabilities().then(res => setVulnerabilities(res.data));
  }, []);

  useEffect(() => {
    if (selectedThreat) {
      getLinksByThreat(selectedThreat.id)
        .then(res => {
          const ids = res.data.map(link => link.vulnerability_id);
          setLinkedVulnIds(ids);
          setSelectedVulnIds(ids);
        })
        .catch(err => {
          console.error(err);
          setSnackbar({ open: true, message: 'Failed to load linked vulnerabilities', severity: 'error' });
        });
    }
  }, [selectedThreat]);

  const handleApply = async () => {
    if (!selectedThreat) return;
    setLoading(true);

    const toAdd = selectedVulnIds.filter(id => !linkedVulnIds.includes(id));
    const toRemove = linkedVulnIds.filter(id => !selectedVulnIds.includes(id));

    try {
      await Promise.all([
        ...toAdd.map(vuln_id =>
          createLink({ threat_id: selectedThreat.id, vulnerability_id: vuln_id })
        ),
        ...toRemove.map(async (vuln_id) => {
          // You may need to get link_id from a separate lookup or adjust your API
          const response = await getLinksByThreat(selectedThreat.id);
          const link = response.data.find(l => l.vulnerability_id === vuln_id);
          if (link) return deleteLink(link.id);
        }),
      ]);
      setLinkedVulnIds(selectedVulnIds);
      setSnackbar({ open: true, message: 'Changes saved', severity: 'success' });
    } catch (err) {
      console.error(err);
      setSnackbar({ open: true, message: 'Failed to save changes', severity: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box sx={{ p: 2 }}>
      <Typography variant="h4" gutterBottom>Threat â€“ Vulnerability Mapping</Typography>
      <Grid container spacing={2}>
        <Grid item xs={5}>
          <ThreatList
            threats={threats}
            selectedThreat={selectedThreat}
            onSelect={setSelectedThreat}
          />
        </Grid>
        <Grid item xs={7}>
          <VulnerabilityList
            vulnerabilities={vulnerabilities}
            selectedVulnIds={selectedVulnIds}
            onToggleVuln={(id) => {
              setSelectedVulnIds(prev =>
                prev.includes(id) ? prev.filter(v => v !== id) : [...prev, id]
              );
            }}
            onApply={handleApply}
            loading={loading}
          />
        </Grid>
      </Grid>
      <Snackbar
        open={snackbar.open}
        autoHideDuration={3000}
        onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
      >
        <Alert
          severity={snackbar.severity}
          onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default ThreatVulnerabilityMapPage;
